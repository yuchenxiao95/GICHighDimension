% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/penalty_selection.R
\name{information_criteria}
\alias{information_criteria}
\alias{Calculate_AIC}
\alias{Calculate_AICc}
\alias{Calculate_AttIC}
\alias{Calculate_SIC}
\alias{Calculate_BIC}
\alias{Calculate_CAIC}
\alias{Calculate_CAICF}
\alias{Calculate_EBIC}
\alias{Calculate_GIC2}
\alias{Calculate_GIC3}
\alias{Calculate_GIC4}
\alias{Calculate_GIC5}
\alias{Calculate_GIC6}
\alias{Calculate_AIC_Short}
\alias{Calculate_AICc_Short}
\alias{Calculate_AttIC_Short}
\alias{Calculate_SIC_Short}
\alias{Calculate_BIC_Short}
\alias{Calculate_CAIC_Short}
\alias{Calculate_CAICF_Short}
\alias{Calculate_EBIC_Short}
\alias{Calculate_GIC2_Short}
\alias{Calculate_GIC3_Short}
\alias{Calculate_GIC4_Short}
\alias{Calculate_GIC5_Short}
\alias{Calculate_GIC6_Short}
\title{Information Criterion Calculations via Julia}
\usage{
Calculate_AIC(Y, X)

Calculate_AICc(Y, X)

Calculate_AttIC(Y, X)

Calculate_SIC(Y, X)

Calculate_BIC(Y, X)

Calculate_CAIC(Y, X)

Calculate_CAICF(Y, X)

Calculate_EBIC(Y, X, P = ncol(X))

Calculate_GIC2(Y, X, P = ncol(X))

Calculate_GIC3(Y, X, P = ncol(X))

Calculate_GIC4(Y, X, P = ncol(X))

Calculate_GIC5(Y, X, P = ncol(X))

Calculate_GIC6(Y, X, P = ncol(X))

Calculate_AIC_Short(Y, X, Inverse)

Calculate_AICc_Short(Y, X, Inverse)

Calculate_AttIC_Short(Y, X, Inverse)

Calculate_SIC_Short(Y, X, Inverse)

Calculate_BIC_Short(Y, X, Inverse)

Calculate_CAIC_Short(Y, X, Inverse)

Calculate_CAICF_Short(Y, X, Inverse)

Calculate_EBIC_Short(Y, X, Inverse, P = ncol(X))

Calculate_GIC2_Short(Y, X, Inverse, P = ncol(X))

Calculate_GIC3_Short(Y, X, Inverse, P = ncol(X))

Calculate_GIC4_Short(Y, X, Inverse, P = ncol(X))

Calculate_GIC5_Short(Y, X, Inverse, P = ncol(X))

Calculate_GIC6_Short(Y, X, Inverse, P = ncol(X))
}
\arguments{
\item{Y}{A numeric response (vector of length n). (Current package assumes univariate Y.)}

\item{X}{A numeric design matrix (n × p).}

\item{P}{(only for EBIC and GIC2–GIC6) integer total number of candidate predictors.
Defaults to \code{ncol(X)}.}

\item{Inverse}{(for \verb{_Short} variants only) a numeric matrix — the inverse of X'X.}
}
\value{
For full versions: a named list with components:
\describe{
\item{CriterionValue}{Numeric scalar of the selected information criterion.}
\item{InverseMatrix}{Matrix inverse used in computation (if applicable).}
}
For \verb{_Short} versions: a numeric scalar of the criterion value.
}
\description{
Compute information criteria using efficient 'Julia' backends via the 'JuliaCall' package.
These functions are useful for variable selection and model comparison in high-dimensional
settings. Each function returns either the computed criterion value, or a list with additional data.
}
\details{
This interface leverages 'Julia' to compute information-theoretic criteria efficiently,
especially when repeatedly evaluating models. Supported criteria include:
\itemize{
\item AIC: Akaike Information Criterion
\item AICc: Corrected AIC for small samples
\item BIC / SIC: Bayesian or Schwarz Information Criterion
\item CAIC: Consistent AIC
\item CAICF: Consistent AIC with Fisher Information
\item EBIC: Extended BIC (depends on the candidate pool size \(P\))
\item GIC2–GIC6: Generalized Information Criterion family (depend on \(P\))
\item AttIC: Attention-weighted Information Criterion
}
Short versions (e.g., \code{Calculate_AIC_Short}) allow reusing a precomputed inverse matrix
to save computational time.
}
\examples{
\dontrun{
if (interactive() && requireNamespace("JuliaCall", quietly = TRUE)) {
  setup_julia(install_julia = FALSE)
  X <- matrix(rnorm(100), ncol = 5)
  Y <- rnorm(20)
  out1 <- Calculate_AIC(Y, X)
  out2 <- Calculate_EBIC(Y, X)        # uses P = ncol(X) by default
  val_short <- Calculate_EBIC_Short(Y, X, solve(crossprod(X)))
}
}

}
