% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GICSelection_Boltzmann.R
\name{GICSelectionBoltzmann}
\alias{GICSelectionBoltzmann}
\title{GIC Variable Selection with Boltzmann Machine}
\usage{
GICSelectionBoltzmann(
  X,
  Y,
  Init_Columns,
  Calculate_GIC,
  Calculate_GIC_short,
  T = 0.2,
  Nsim = 2
)
}
\arguments{
\item{X}{Design matrix (numeric).}

\item{Y}{Outcome vector (numeric).}

\item{Init_Columns}{Initial subset of feature indices (integer vector).}

\item{Calculate_GIC}{Name of the Julia function to calculate GIC (string).}

\item{Calculate_GIC_short}{Name of the Julia function for short GIC updates (string).}

\item{T}{Temperature parameter controlling the randomness of updates (default 0.2).}

\item{Nsim}{Number of times to repeat the selection process (default 2).}
}
\value{
A list containing GIC values and corresponding coefficients.
}
\description{
This function performs GIC-based variable selection using a Boltzmann-like
simulated annealing approach, which is implemented in Julia.
}
\details{
The method uses temperature control for randomness in the variable selection process.
}
\examples{
\dontrun{
if (requireNamespace("JuliaCall", quietly = TRUE)) {
  julia_available <- FALSE
  tryCatch({
    JuliaCall::julia_setup(installJulia = FALSE)
    julia_available <- TRUE
  }, error = function(e) {
    message("Julia not available: ", e$message)
  })

  if (julia_available) {
    # Generate synthetic data
    set.seed(123)
    n <- 100
    p <- 10
    k <- 3

    X <- matrix(rnorm(n * p), n, p)
    true_beta <- c(rep(1.5, k), rep(0, p - k))
    Y <- X \%*\% true_beta + rnorm(n)

    # Run Boltzmann GIC selection
    result <- GICSelectionBoltzmann(
      X = X,
      Y = Y,
      Init_Columns = 1:p,
      Calculate_GIC = "Calculate_SIC",
      Calculate_GIC_short = "Calculate_SIC_short",
      Nsim = 3
    )

    # Print selected coefficients
    print(result$GIC_coeff)
  }
}
}

}
