% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GICSelection_Boltzmann.R
\name{GICSelectionBoltzmann}
\alias{GICSelectionBoltzmann}
\title{GIC-Based Variable Selection Using Boltzmann Machine}
\usage{
GICSelectionBoltzmann(
  X,
  Y,
  Init_Columns,
  Calculate_GIC,
  Calculate_GIC_short,
  T = 0.1,
  Nsim = 5
)
}
\arguments{
\item{X}{A numeric design matrix with \code{n} rows (observations) and \code{p} columns (predictors).}

\item{Y}{A numeric response vector (length \code{n}) or matrix compatible with \code{X}.}

\item{Init_Columns}{Integer vector of indices specifying the initial set of predictors.}

\item{Calculate_GIC}{Character string giving the name of the 'Julia' function to compute full GIC values.}

\item{Calculate_GIC_short}{Character string giving the name of the 'Julia' function to compute approximate GIC values.}

\item{T}{Numeric scalar. The temperature parameter controlling stochasticity in the simulated annealing process (default: 0.1).}

\item{Nsim}{Integer. Number of repeated runs for the optimization procedure (default: 5).}
}
\value{
A list with the following components:
\describe{
\item{\code{GIC_list}}{List of GIC values returned for each run.}
\item{\code{GIC_coeff}}{Indices of the variables selected in the final run.}
}
}
\description{
Performs variable selection using the Generalized Information Criterion ('GIC')
combined with a Boltzmann-like simulated annealing approach. The optimization logic
is implemented in 'Julia' and accessed from 'R' through the 'JuliaCall' interface.
}
\details{
This method uses temperature-based control to introduce stochasticity in
model exploration. It supports custom GIC formulations by passing the names of
'Julia' functions and works with both univariate and multivariate responses.
}
\examples{
\dontrun{
if (requireNamespace("JuliaCall", quietly = TRUE)) {
  julia_available <- FALSE
  tryCatch({
    JuliaCall::julia_setup(installJulia = FALSE)
    julia_available <- TRUE
  }, error = function(e) {
    message("Julia not available: ", e$message)
  })

  if (julia_available) {
    set.seed(123)
    n <- 100; p <- 10; k <- 3
    X <- matrix(rnorm(n * p), n, p)
    beta <- c(rep(1.5, k), rep(0, p - k))
    Y <- X \%*\% beta + rnorm(n)

    result <- GICSelectionBoltzmann(
      X = X,
      Y = Y,
      Init_Columns = 1:p,
      Calculate_GIC = "Calculate_SIC",
      Calculate_GIC_short = "Calculate_SIC_short",
      Nsim = 3
    )
    print(result$GIC_coeff)
  }
}
}

}
