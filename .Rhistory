indices <- result$indices
set.seed(101)
# Step 1: Generate X from a multivariate normal distribution
N <- 8000  # Number of observations
P <- 200   # Number of predictors
k <- 16
SNR = c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
init_cols = sort(sample(1:P, P/3, replace = FALSE))
rho = 0
# Set mean vector and covariance matrix
mu <- rep(0, P)  # Mean vector
cov <- matrix(rho, P, P)
diag(cov) <- 1  # Covariance matrix with specified correlation
# Generate the design matrix X
X <- mvrnorm(N, mu, cov)
result <- Beta_Generation(P, k, type = 3)
true_beta <- result$beta
indices <- result$indices
Y = LP_to_Y(X, true_beta, family = "Normal", std = 1.0)
init_cols = init_cols <- seq(1,P)
time <- system.time(result1 <- GICSelection(X, Y, init_cols, "Calculate_SIC", "Calculate_SIC_short", Nsim = 1))["elapsed"]
time
# Set seed for reproducibility
set.seed(101)
# Step 1: Generate X from a multivariate normal distribution
N <- 5000  # Number of observations
P <- 200   # Number of predictors
k <- 16
SNR = c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
init_cols = sort(sample(1:P, P/3, replace = FALSE))
rho = 0
# Set mean vector and covariance matrix
mu <- rep(0, P)  # Mean vector
cov <- matrix(rho, P, P)
diag(cov) <- 1  # Covariance matrix with specified correlation
# Generate the design matrix X
X <- mvrnorm(N, mu, cov)
result <- Beta_Generation(P, k, type = 3)
true_beta <- result$beta
indices <- result$indices
Y = LP_to_Y(X, true_beta, family = "Normal", std = 1.0)
init_cols = init_cols <- seq(1,P)
time <- system.time(result1 <- GICSelection(X, Y, init_cols, "Calculate_SIC", "Calculate_SIC_short", Nsim = 1))["elapsed"]
time
# This file is part of the standard setup for testthat.
# It is recommended that you do not modify it.
#
# Where should you do additional test configuration?
# Learn more about the roles of various files in:
# * https://r-pkgs.org/testing-design.html#sec-tests-files-overview
# * https://testthat.r-lib.org/articles/special-files.html
# testthat.R
library(testthat)
library(GICModelSelection)
library(GICModelSelection)
# Document the changes
devtools::document()
# test the changes
devtools::load_all()
# installing a custom-built R package
devtools::install(build_vignettes = FALSE, force = TRUE)
# verify the julia script paths
JuliaCall::julia_setup("/Applications/Julia-1.9.app/Contents/Resources/julia/bin")
#JuliaCall::julia_setup()
library(testthat)
library(GICHighDimension)
test_that("Univariate Normal Model Selection works", {
N <- 1000
P <- 500
k <- 5
rho <- 0.0
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
X <- JuliaCall::julia_eval("Matrix(rand(MvNormal(mu, cov), N)")
# Create true beta
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
variance <- (t(true_beta) %*% cov_matrix %*% true_beta) / SNR[5]
std_dev <- sqrt(variance)
# Generate response
Y <- LP_to_Y(X, true_beta, family = "Normal", std = std_dev)
# Run model selection
init_cols <- 1:P
result <- GIC_Variable_Selection(X, Y, init_cols,
Calculate_BIC, Calculate_BIC_short,
Nsim = 5)
# Tests
expect_type(result[[1]], "double")
expect_type(result[[2]], "list")
expect_lte(length(setdiff(true_columns, result[[2]][[length(result[[2]])]]), k)
expect_gte(length(setdiff(result[[2]][[length(result[[2]])]], true_columns)), 0)
# testthat.R
library(testthat)
library(GICHighDimension)
test_that("Univariate Normal Model Selection works", {
# Set parameters
N <- 1000
P <- 500
k <- 5
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using Julia
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
X <- JuliaCall::julia_eval("Matrix(rand(MvNormal(mu, cov), N)'")
# Create true beta coefficients
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
variance <- (t(true_beta) %*% cov_matrix %*% true_beta) / SNR[5]
std_dev <- sqrt(variance)
# Generate response variable
Y <- LP_to_Y(X, true_beta, family = "Normal", std = std_dev)
# Run model selection
init_cols <- 1:P
result <- GIC_Variable_Selection(
X = X,
Y = Y,
init_cols = init_cols,
GIC_long = Calculate_BIC,
GIC_short = Calculate_BIC_short,
Nsim = 5
)
# Extract final selection
final_selection <- result[[2]][[length(result[[2]])]]
# Perform tests
expect_type(result[[1]], "double")  # Check coefficients type
expect_type(result[[2]], "list")    # Check selection path type
expect_lte(length(setdiff(true_columns, final_selection)), k)  # False negatives
expect_gte(length(setdiff(final_selection, true_columns)), 0)  # False positives
})
# Set parameters
N <- 1000
P <- 500
k <- 5
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using Julia
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
X <- JuliaCall::julia_eval("Matrix(rand(MvNormal(mu, cov), N)'")
# Set parameters
N <- 1000
P <- 500
k <- 5
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using Julia
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
X <- JuliaCall::julia_eval("Matrix(rand(MvNormal(mu, cov), N)'")
N <- 1000
P <- 500
k <- 5
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using Julia
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
JuliaCall::julia_eval("Matrix(rand(MvNormal(mu, cov), N)'")
# Initialize Julia connection
JuliaCall::julia_setup()
# Set parameters
N <- 1000
P <- 500
k <- 5
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using proper Julia syntax
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Correct Julia matrix generation
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Initialize Julia connection
JuliaCall::julia_setup()
JuliaCall::julia_library("Distributions")
c
# Set parameters
N <- 1000L  # Explicitly integer
P <- 500L
k <- 5L
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using proper Julia syntax
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Correct Julia matrix generation
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
# Proper random matrix generation
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
variance <- (t(true_beta) %*% cov_matrix %*% true_beta) / SNR[5]
std_dev <- sqrt(variance)
# Generate response variable
Y <- LP_to_Y(X, true_beta, family = "Normal", std = std_dev)
# This file is part of the standard setup for testthat.
# It is recommended that you do not modify it.
#
# Where should you do additional test configuration?
# Learn more about the roles of various files in:
# * https://r-pkgs.org/testing-design.html#sec-tests-files-overview
# * https://testthat.r-lib.org/articles/special-files.html
# testthat.R
library(testthat)
library(GICHighDimension)
# Initialize Julia connection
JuliaCall::julia_setup()
JuliaCall::julia_library("Distributions")
test_that("Univariate Normal Model Selection works", {
# Set parameters
N <- 1000L  # Explicitly integer
P <- 500L
k <- 5L
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using proper Julia syntax
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Correct Julia matrix generation
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
# Proper random matrix generation
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
variance <- (t(true_beta) %*% cov_matrix %*% true_beta) / SNR[5]
std_dev <- sqrt(variance)
# Generate response variable
Y <- LP_to_Y(X, true_beta, family = "Normal", std = std_dev)
# Run model selection
init_cols <- 1:P
result <- GIC_Variable_Selection(
X = X,
Y = Y,
init_cols = init_cols,
GIC_long = Calculate_BIC,
GIC_short = Calculate_BIC_short,
Nsim = 5L
)
# Extract final selection
final_selection <- result$selection_path[[length(result$selection_path)]]
# Perform tests
expect_type(result$coefficients, "double")
expect_type(result$selection_path, "list")
expect_lte(length(setdiff(true_columns, final_selection)), k)
expect_gte(length(setdiff(final_selection, true_columns)), 0)
})
# Set parameters
N <- 1000L  # Explicitly integer
P <- 500L
k <- 5L
rho <- 0.0
# Generate true columns and SNR values
true_columns <- sort(sample(1:P, k, replace = FALSE))
SNR <- c(0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07, 3.52, 6.00)
# Create design matrix using proper Julia syntax
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Correct Julia matrix generation
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
# Proper random matrix generation
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
variance <- (t(true_beta) %*% cov_matrix %*% true_beta) / SNR[5]
std_dev <- sqrt(variance)
# Generate response variable
Y <- LP_to_Y(X, true_beta, family = "Normal", std = std_dev)
# Run model selection
init_cols <- 1:P
result <- GIC_Variable_Selection(
X = X,
Y = Y,
init_cols = init_cols,
GIC_long = Calculate_BIC,
GIC_short = Calculate_BIC_short,
Nsim = 5L
)
LP_to_Y
GIC_Variable_Selection
# Run model selection
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols = init_cols,
GIC_long = Calculate_BIC,
GIC_short = Calculate_BIC_short,
Nsim = 5L
)
result <- GICSelection(
X = X,
Y = Y,
init_cols = init_cols,
'Calculate_BIC',
'Calculate_BIC_short',
Nsim = 5
)
# Run model selection
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols = init_cols,
'Calculate_BIC',
'Calculate_BIC_short',
Nsim = 5
)
result <- GICSelection(
X = X,
Y = Y,
init_cols,
'Calculate_BIC',
'Calculate_BIC_short',
Nsim = 5
)
# Extract final selection
final_selection <- result$selection_path[[length(result$selection_path)]]
final_selection
result
# Initialize Julia connection
JuliaCall::julia_setup()
JuliaCall::julia_library("Distributions")
# Set parameters
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Generate true columns
true_columns <- sort(sample(1:P, k, replace = FALSE))
# Create design matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Generate random matrix in Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
# Generate response
Y <- LP_to_Y(X, true_beta, family = "Normal")
# Run model selection
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols,
"Calculate_BIC",
"Calculate_BIC_short",
Nsim = 5L
)
# Tests for the result structure
expect_true(all(c("GIC_list", "GIC_coeff") %in% names(result)))
expect_type(result$GIC_list, "double")
expect_type(result$GIC_coeff, "double")
result
expect_true(all(c("GIC_list", "GIC_coeff") %in% names(result)))
expect_type(result$GIC_list, "double")
result$GIC_list
result$GIC_list)
result$GIC_list
result$GIC_coeff
setdiff
setdiff(result$GIC_list,   true_columns )
setdiff(result$GIC_coeff,   true_columns )
result$GIC_coeff[end]
result$GIC_coeff
result$GIC_coeff[-1]
result$GIC_coeff[[length(result$GIC_coeff)]]
setdiff(result$GIC_coeff[[length(result$GIC_coeff)]], true_columns)
true_columns
setdiff( true_columns, result$GIC_coeff[[length(result$GIC_coeff)]])
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
Y <- LP_to_Y(X, multi_beta, family = "MultivariateNormal")
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Create mean vector and covariance matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Assign to Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
true_signal_columns <- unique(unlist(multi_beta_true_columns))
# Create response covariance matrix (different from design matrix)
response_cov <- matrix(0.5, m, m)  # Example: 0.5 correlation between responses
diag(response_cov) <- 1.0          # Unit variance
# Generate response - NOW WITH COV_MATRIX SPECIFIED
Y <- LP_to_Y(
X = X,
true_beta = multi_beta,
family = "MultivariateNormal",
cov_matrix = response_cov  # This was missing!
)
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Create mean vector and covariance matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Assign to Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
true_signal_columns <- unique(unlist(multi_beta_true_columns))
# Create response covariance matrix (different from design matrix)
response_cov <- matrix(0.5, m, m)  # Example: 0.5 correlation between responses
diag(response_cov) <- 1.0          # Unit variance
# Generate response - NOW WITH COV_MATRIX SPECIFIED
Y <- LP_to_Y(
X = X,
true_beta = multi_beta,
family = "MultivariateNormal",
cov_matrix = response_cov  # This was missing!
)
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols,
"Calculate_SIC",
"Calculate_SIC_short",
Nsim = 8L
)
setdiff(result$GIC_coeff[[length(result$GIC_coeff)]],   true_signal_columns )
setdiff(true_signal_columns , result$GIC_coeff[[length(result$GIC_coeff)]])
# First-time setup (installs Julia if missing)
GICModelSelection::setup_julia()
GICHighDimension::setup_julia()
