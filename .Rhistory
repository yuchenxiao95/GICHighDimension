)["elapsed"]
beta_full <- coef(ab, support.size = ab$best.size, sparse = FALSE)
intercept <- beta_full[1]; beta_hat <- beta_full[-1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "abess", beta_full, sel, mu_tr, mu_te)
## ---- (3) MCP/SCAD -------------------------------------------------------
for (pen in c("MCP", "SCAD")) {
t <- system.time(cv <- cv.ncvreg(X_tr, Y_tr, penalty=pen, family = ab_family))["elapsed"]
beta_full <- coef(cv); beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("ncvreg-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (4) Lasso -------------------------------------------------------
t <- system.time(cvg <- cv.glmnet(X_tr, Y_tr, family= ab_family, alpha=1))["elapsed"]
beta_full <- as.vector(coef(cvg, s="lambda.min"))
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "glmnet-Lasso", beta_full, sel, mu_tr, mu_te)
tbl
})
combined <- bind_rows(replicate_tables)
summary_df <- combined %>%
group_by(Rho, SNR, Method) %>%
summarise(across(
Time:Test_Dev,
list(mean = ~mean(.x, na.rm=TRUE),
se   = ~sd(.x, na.rm=TRUE) / sqrt(n_rep)),
.names = "{.col}_{.fn}"),
.groups = "drop")
fam_table[[paste0("rho_", round(rho,2), "_snr_", round(snr,2))]] <- summary_df
}
}
full_summary <- bind_rows(fam_table)
write.csv(full_summary,
file = file.path(results_dir, paste0("summary_N", N, "_", fam, "_results.csv")),
row.names = FALSE)
}
}
library(MASS)               # mvrnorm
library(GICHighDimension)   # Generate_Beta, LP_to_Y, Beta_estimate, GICSelection
library(abess)
library(ncvreg)
library(glmnet)
library(dplyr)
library(future.apply)       # parallel backend
library(JuliaCall)
JuliaCall::julia_setup("C:/Users/yuchen/AppData/Local/Programs/Julia-1.10.9/bin/julia.exe")
plan(multisession)
options(future.rng.onMisuse = "ignore")
results_dir <- "/Users/yuchen/Library/CloudStorage/Dropbox/Mac/Documents/Research/Model Selection/Manuscript/Data"
if (!dir.exists(results_dir)) dir.create(results_dir)
plan(multisession)
options(future.rng.onMisuse = "ignore")
results_dir <- "/Users/yuchen/Library/CloudStorage/Dropbox/Mac/Documents/Research/Model Selection/Manuscript/Data"
if (!dir.exists(results_dir)) dir.create(results_dir)
# ── Constants ──────────────────────────────────────────────────────
Ns <- c(3000, 6000)
P <- 500; k <- 10
rho_grid <- c(0.0, 0.30, 0.60)
SNR_grid <- c(0.05, 0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07)
ntrial <- 1
n_rep <- 30
families <- c("Normal", "Weibull", "t3", "Binomial", "Poisson")
gic_map <- list(SIC=c("Calculate_SIC","Calculate_SIC_short"),
BIC=c("Calculate_BIC","Calculate_BIC_short"),
GIC6=c("Calculate_GIC6","Calculate_GIC6_short"))
safe_LP <- function(y, fam, ntrial=1) {
switch(fam,
Binomial = Y_to_LP(pmin(y, ntrial), "Binomial", n_trials=ntrial),
Poisson  = Y_to_LP(pmin(y, 1e6), "Poisson"),
y)
}
metric_vec <- function(beta_hat, beta_true, idx_sel, idx_true) {
if (length(beta_hat) == length(beta_true) + 1) beta_hat <- beta_hat[-1]
c(L2 = sqrt(sum((beta_hat - beta_true)^2)),
FP = length(setdiff(idx_sel, idx_true)),
FN = length(setdiff(idx_true, idx_sel)))
}
weibull_scale_from_snr <- function(beta, rho, snr, shape = 1.5) {
P <- length(beta)
Sigma <- matrix(rho, P, P)
diag(Sigma) <- 1
var_signal <- as.numeric(t(beta) %*% Sigma %*% beta)
gamma1 <- gamma(1 + 1 / shape)
gamma2 <- gamma(1 + 2 / shape)
var_weibull <- gamma2 - gamma1^2
lambda <- sqrt(var_signal / (snr * var_weibull))
return(lambda)
}
family_mean <- function(eta, fam, ntrial = 1) {
switch(fam,
Normal = eta, Weibull = eta, t3 = eta,
Binomial = ntrial * plogis(eta),
Poisson = exp(eta))
}
##############################################################################
## (REPLACE the old deviance_glm() with this version) ------------------------
##############################################################################
deviance_glm <- function(y, mu, fam, ntrial = 1L) {
eps <- 1e-15   # avoid log(0)
switch(fam,
# ---- Binomial counts ---------------------------------------------------
Binomial = {
mu <- pmin(pmax(mu, eps), ntrial - eps)  # keep μ inside (0, m)
d  <- ifelse(y == 0,      0,  y             * log(y / mu)) +
ifelse(y == ntrial, 0,  (ntrial - y) * log((ntrial - y) /
(ntrial - mu)))
mean(2 * d)                              # per-observation deviance
},
# ---- Poisson -----------------------------------------------------------
Poisson = {
mu <- pmax(mu, eps)
d  <- ifelse(y == 0, 0, y * log(y / mu)) - (y - mu)
mean(2 * d)
},
# ---- Any other family --------------------------------------------------
NA_real_
)
}
loss_mse <- function(y, mu, fam) {
if (fam %in% c("Normal", "Weibull", "t3")) mean((y - mu)^2) else NA_real_
}
beta_from_selection <- function(Xs, Ys, fam, ntrial) {
Beta_estimate(Xs, Ys,
family = if (fam %in% c("Normal", "Weibull", "t3")) "Linear" else fam,
n_trials = if (fam == "Binomial") ntrial else NULL,
add_intercept = fam %in% c("Normal", "Weibull", "t3"))
}
# ── Main loop ──────────────────────────────────────────────────────
for (N in Ns) {
cat("Running sample size N =", N, "\n")
beta_obj <- Generate_Beta(P, k, type = 1)
beta_true <- beta_obj$beta
idx_true <- beta_obj$indices
for (fam in families) {
cat("  Family:", fam, "\n")
fam_table <- list()
ab_family <- switch(fam,
"Normal"   = "gaussian",
"Weibull"  = "gaussian",
"t3"       = "gaussian",
"Binomial" = "binomial",
"Poisson"  = "poisson"
)
rho_loop <- if (fam == "Poisson") c(0.0, 0.1) else rho_grid
for (rho in rho_grid) {
cat("rho =", rho, "\n")
Sigma <- matrix(rho, P, P); diag(Sigma) <- 1
X <- mvrnorm(N, rep(0, P), Sigma)
train_id <- sample(N, 0.8 * N)
test_id <- setdiff(seq_len(N), train_id)
X_tr <- X[train_id, ]; X_te <- X[test_id, ]
init_cols <- sample.int(P,               # draw indices from 1 … P
size = floor(0.8 * P),   # 60 %
replace = FALSE)         # no duplicates
for (snr in SNR_grid) {
cat("snr", snr, "\n")
var_lin <- as.numeric(t(beta_true) %*% Sigma %*% beta_true) / snr
sd_lin <- sqrt(var_lin)
replicate_tables <- future_lapply(seq_len(n_rep), function(rep_id) {
Y <- switch(fam,
Normal   = LP_to_Y(X, beta_true, "Normal", std=sd_lin),
lambda = weibull_scale_from_snr(beta, rho, snr),
Weibull  = as.vector(X %*% beta_true) + rweibull(N, 1.5, lambda),
t3       = as.vector(X %*% beta_true) + rt(N, 3) * sd_lin,
Binomial = LP_to_Y(X, beta_true, "Binomial", n_trials=ntrial),
Poisson  = LP_to_Y(X, beta_true, "Poisson"))
Y_tr <- Y[train_id]; Y_te <- Y[test_id]
LP_tr <- safe_LP(Y_tr, fam, ntrial)
tbl <- data.frame(Method = character())
add_row <- function(df, time, lab, bfull, sel, mu_tr, mu_te) {
mvec <- metric_vec(bfull, beta_true, sel, idx_true)
rbind(df, data.frame(
Rho = rho, SNR = snr, Method = lab, Time = time,
L2 = mvec["L2"], FP = mvec["FP"], FN = mvec["FN"],
Train_Loss = loss_mse(Y_tr, mu_tr, fam),
Test_Loss  = loss_mse(Y_te, mu_te, fam),
Train_Dev  = deviance_glm(Y_tr, mu_tr, fam, ntrial),
Test_Dev   = deviance_glm(Y_te, mu_te, fam, ntrial)))
}
## ---- (1) GIC -------------------------------------------------------
for (pen in names(gic_map)) {
t <- system.time(gsel <- GICSelection(X_tr, LP_tr, init_cols,
gic_map[[pen]][1], gic_map[[pen]][2], Nsim=4))["elapsed"]
sel <- gsel$selected_coeffs[[length(gsel$selected_coeffs)]]
fit <- if (length(sel)) beta_from_selection(X_tr[, sel, drop=FALSE], Y_tr, fam, ntrial)
else c(0, numeric(P))
beta_full <- c(fit[1], numeric(P)); beta_full[sel + 1] <- fit[-1]
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("GIC-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (2) abess -------------------------------------------------------
t <- system.time(
ab <- abess(y ~ ., data = cbind.data.frame(y = Y_tr, X_tr),
family =  ab_family)
)["elapsed"]
beta_full <- coef(ab, support.size = ab$best.size, sparse = FALSE)
intercept <- beta_full[1]; beta_hat <- beta_full[-1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "abess", beta_full, sel, mu_tr, mu_te)
## ---- (3) MCP/SCAD -------------------------------------------------------
for (pen in c("MCP", "SCAD")) {
t <- system.time(cv <- cv.ncvreg(X_tr, Y_tr, penalty=pen, family = ab_family))["elapsed"]
beta_full <- coef(cv); beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("ncvreg-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (4) Lasso -------------------------------------------------------
t <- system.time(cvg <- cv.glmnet(X_tr, Y_tr, family= ab_family, alpha=1))["elapsed"]
beta_full <- as.vector(coef(cvg, s="lambda.min"))
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "glmnet-Lasso", beta_full, sel, mu_tr, mu_te)
tbl
})
combined <- bind_rows(replicate_tables)
summary_df <- combined %>%
group_by(Rho, SNR, Method) %>%
summarise(across(
Time:Test_Dev,
list(mean = ~mean(.x, na.rm=TRUE),
se   = ~sd(.x, na.rm=TRUE) / sqrt(n_rep)),
.names = "{.col}_{.fn}"),
.groups = "drop")
fam_table[[paste0("rho_", round(rho,2), "_snr_", round(snr,2))]] <- summary_df
}
}
full_summary <- bind_rows(fam_table)
write.csv(full_summary,
file = file.path(results_dir, paste0("summary_N", N, "_", fam, "_results.csv")),
row.names = FALSE)
}
}
library(MASS)               # mvrnorm
library(GICHighDimension)   # Generate_Beta, LP_to_Y, Beta_estimate, GICSelection
library(abess)
library(ncvreg)
library(glmnet)
library(dplyr)
library(future.apply)       # parallel backend
library(JuliaCall)
JuliaCall::julia_setup("C:/Users/yuchen/AppData/Local/Programs/Julia-1.10.9/bin/julia.exe")
library(MASS)               # mvrnorm
library(GICHighDimension)   # Generate_Beta, LP_to_Y, Beta_estimate, GICSelection
library(abess)
library(ncvreg)
library(glmnet)
library(dplyr)
library(future.apply)       # parallel backend
library(JuliaCall)
JuliaCall::julia_setup("C:/Users/yuchen/AppData/Local/Programs/Julia-1.10.9/bin/julia.exe")
JuliaCall::julia_setup(
"/Applications/Julia-1.9.app/Contents/Resources/julia/bin"
)
plan(multisession)
options(future.rng.onMisuse = "ignore")
results_dir <- "/Users/yuchen/Library/CloudStorage/Dropbox/Mac/Documents/Research/Model Selection/Manuscript/Data"
if (!dir.exists(results_dir)) dir.create(results_dir)
Ns <- c(3000, 6000)
P <- 500; k <- 10
rho_grid <- c(0.0, 0.30)
SNR_grid <- c(0.05, 0.09, 0.14, 0.25, 0.42, 0.71, 1.22, 2.07)
ntrial <- 1
n_rep <- 10
families <- c("Normal", "t3", "Binomial", "Poisson")
gic_map <- list(SIC=c("Calculate_SIC","Calculate_SIC_short"),
BIC=c("Calculate_BIC","Calculate_BIC_short"),
GIC6=c("Calculate_GIC6","Calculate_GIC6_short"))
safe_LP <- function(y, fam, ntrial=1) {
switch(fam,
Binomial = Y_to_LP(pmin(y, ntrial), "Binomial", n_trials=ntrial),
Poisson  = Y_to_LP(pmin(y, 1e6), "Poisson"),
y)
}
metric_vec <- function(beta_hat, beta_true, idx_sel, idx_true) {
if (length(beta_hat) == length(beta_true) + 1) beta_hat <- beta_hat[-1]
c(L2 = sqrt(sum((beta_hat - beta_true)^2)),
FP = length(setdiff(idx_sel, idx_true)),
FN = length(setdiff(idx_true, idx_sel)))
}
weibull_scale_from_snr <- function(beta, rho, snr, shape = 1.5) {
P <- length(beta)
Sigma <- matrix(rho, P, P)
diag(Sigma) <- 1
var_signal <- as.numeric(t(beta) %*% Sigma %*% beta)
gamma1 <- gamma(1 + 1 / shape)
gamma2 <- gamma(1 + 2 / shape)
var_weibull <- gamma2 - gamma1^2
lambda <- sqrt(var_signal / (snr * var_weibull))
return(lambda)
}
family_mean <- function(eta, fam, ntrial = 1) {
switch(fam,
Normal = eta, Weibull = eta, t3 = eta,
Binomial = ntrial * plogis(eta),
Poisson = exp(eta))
}
deviance_glm <- function(y, mu, fam, ntrial = 1L) {
eps <- 1e-15   # avoid log(0)
switch(fam,
# ---- Binomial counts ---------------------------------------------------
Binomial = {
mu <- pmin(pmax(mu, eps), ntrial - eps)  # keep μ inside (0, m)
d  <- ifelse(y == 0,      0,  y             * log(y / mu)) +
ifelse(y == ntrial, 0,  (ntrial - y) * log((ntrial - y) /
(ntrial - mu)))
mean(2 * d)                              # per-observation deviance
},
# ---- Poisson -----------------------------------------------------------
Poisson = {
mu <- pmax(mu, eps)
d  <- ifelse(y == 0, 0, y * log(y / mu)) - (y - mu)
mean(2 * d)
},
# ---- Any other family --------------------------------------------------
NA_real_
)
}
loss_mse <- function(y, mu, fam) {
if (fam %in% c("Normal", "Weibull", "t3")) mean((y - mu)^2) else NA_real_
}
beta_from_selection <- function(Xs, Ys, fam, ntrial) {
Beta_estimate(Xs, Ys,
family = if (fam %in% c("Normal", "Weibull", "t3")) "Linear" else fam,
n_trials = if (fam == "Binomial") ntrial else NULL,
add_intercept = fam %in% c("Normal", "Weibull", "t3"))
}
Ns
N = 3000
cat("Running sample size N =", N, "\n")
beta_obj <- Generate_Beta(P, k, type = 1)
beta_true <- beta_obj$beta
idx_true <- beta_obj$indices
fam = "Normal"
cat("  Family:", fam, "\n")
fam_table <- list()
ab_family <- switch(fam,
"Normal"   = "gaussian",
"Weibull"  = "gaussian",
"t3"       = "gaussian",
"Binomial" = "binomial",
"Poisson"  = "poisson"
)
rho_l
fam = "Normal"
cat("  Family:", fam, "\n")
fam_table <- list()
ab_family <- switch(fam,
"Normal"   = "gaussian",
"Weibull"  = "gaussian",
"t3"       = "gaussian",
"Binomial" = "binomial",
"Poisson"  = "poisson"
)
rho_loop <- if (fam == "Poisson") c(0.0, 0.1) else rho_grid
rhp = 0.1
cat("rho =", rho, "\n")
rho = 0.1
cat("rho =", rho, "\n")
Sigma <- matrix(rho, P, P); diag(Sigma) <- 1
X <- mvrnorm(N, rep(0, P), Sigma)
train_id <- sample(N, 0.8 * N)
test_id <- setdiff(seq_len(N), train_id)
X_tr <- X[train_id, ]; X_te <- X[test_id, ]
init_cols <- sample.int(P,               # draw indices from 1 … P
size = floor(0.8 * P),   # 60 %
replace = FALSE)         # no duplicates
snr=0.3
cat("snr", snr, "\n")
var_lin <- as.numeric(t(beta_true) %*% Sigma %*% beta_true) / snr
sd_lin <- sqrt(var_lin)
Y <- switch(fam,
Normal   = LP_to_Y(X, beta_true, "Normal", std=sd_lin),
lambda = weibull_scale_from_snr(beta, rho, snr),
Weibull  = as.vector(X %*% beta_true) + rweibull(N, 1.5, lambda),
t3       = as.vector(X %*% beta_true) + rt(N, 3) * sd_lin,
Binomial = LP_to_Y(X, beta_true, "Binomial", n_trials=ntrial),
Poisson  = LP_to_Y(X, beta_true, "Poisson"))
Y_tr <- Y[train_id]; Y_te <- Y[test_id]
LP_tr <- safe_LP(Y_tr, fam, ntrial)
tbl <- data.frame(Method = character())
add_row <- function(df, time, lab, bfull, sel, mu_tr, mu_te) {
mvec <- metric_vec(bfull, beta_true, sel, idx_true)
rbind(df, data.frame(
Rho = rho, SNR = snr, Method = lab, Time = time,
L2 = mvec["L2"], FP = mvec["FP"], FN = mvec["FN"],
Train_Loss = loss_mse(Y_tr, mu_tr, fam),
Test_Loss  = loss_mse(Y_te, mu_te, fam),
Train_Dev  = deviance_glm(Y_tr, mu_tr, fam, ntrial),
Test_Dev   = deviance_glm(Y_te, mu_te, fam, ntrial)))
}
## ---- (1) GIC -------------------------------------------------------
for (pen in names(gic_map)) {
t <- system.time(gsel <- GICSelection(X_tr, LP_tr, init_cols,
gic_map[[pen]][1], gic_map[[pen]][2], Nsim=4))["elapsed"]
sel <- gsel$selected_coeffs[[length(gsel$selected_coeffs)]]
fit <- if (length(sel)) beta_from_selection(X_tr[, sel, drop=FALSE], Y_tr, fam, ntrial)
else c(0, numeric(P))
beta_full <- c(fit[1], numeric(P)); beta_full[sel + 1] <- fit[-1]
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("GIC-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (2) abess -------------------------------------------------------
t <- system.time(
ab <- abess(y ~ ., data = cbind.data.frame(y = Y_tr, X_tr),
family =  ab_family)
)["elapsed"]
beta_full <- coef(ab, support.size = ab$best.size, sparse = FALSE)
intercept <- beta_full[1]; beta_hat <- beta_full[-1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "abess", beta_full, sel, mu_tr, mu_te)
## ---- (3) MCP/SCAD -------------------------------------------------------
for (pen in c("MCP", "SCAD")) {
t <- system.time(cv <- cv.ncvreg(X_tr, Y_tr, penalty=pen, family = ab_family))["elapsed"]
beta_full <- coef(cv); beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("ncvreg-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (4) Lasso -------------------------------------------------------
t <- system.time(cvg <- cv.glmnet(X_tr, Y_tr, family= ab_family, alpha=1))["elapsed"]
beta_full <- as.vector(coef(cvg, s="lambda.min"))
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "glmnet-Lasso", beta_full, sel, mu_tr, mu_te)
tbl
replicate_tables <- future_lapply(seq_len(n_rep), function(rep_id) {
Y <- switch(fam,
Normal   = LP_to_Y(X, beta_true, "Normal", std=sd_lin),
lambda = weibull_scale_from_snr(beta, rho, snr),
Weibull  = as.vector(X %*% beta_true) + rweibull(N, 1.5, lambda),
t3       = as.vector(X %*% beta_true) + rt(N, 3) * sd_lin,
Binomial = LP_to_Y(X, beta_true, "Binomial", n_trials=ntrial),
Poisson  = LP_to_Y(X, beta_true, "Poisson"))
Y_tr <- Y[train_id]; Y_te <- Y[test_id]
LP_tr <- safe_LP(Y_tr, fam, ntrial)
tbl <- data.frame(Method = character())
add_row <- function(df, time, lab, bfull, sel, mu_tr, mu_te) {
mvec <- metric_vec(bfull, beta_true, sel, idx_true)
rbind(df, data.frame(
Rho = rho, SNR = snr, Method = lab, Time = time,
L2 = mvec["L2"], FP = mvec["FP"], FN = mvec["FN"],
Train_Loss = loss_mse(Y_tr, mu_tr, fam),
Test_Loss  = loss_mse(Y_te, mu_te, fam),
Train_Dev  = deviance_glm(Y_tr, mu_tr, fam, ntrial),
Test_Dev   = deviance_glm(Y_te, mu_te, fam, ntrial)))
}
## ---- (1) GIC -------------------------------------------------------
for (pen in names(gic_map)) {
t <- system.time(gsel <- GICSelection(X_tr, LP_tr, init_cols,
gic_map[[pen]][1], gic_map[[pen]][2], Nsim=3))["elapsed"]
sel <- gsel$selected_coeffs[[length(gsel$selected_coeffs)]]
fit <- if (length(sel)) beta_from_selection(X_tr[, sel, drop=FALSE], Y_tr, fam, ntrial)
else c(0, numeric(P))
beta_full <- c(fit[1], numeric(P)); beta_full[sel + 1] <- fit[-1]
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("GIC-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (2) abess -------------------------------------------------------
t <- system.time(
ab <- abess(y ~ ., data = cbind.data.frame(y = Y_tr, X_tr),
family =  ab_family)
)["elapsed"]
beta_full <- coef(ab, support.size = ab$best.size, sparse = FALSE)
intercept <- beta_full[1]; beta_hat <- beta_full[-1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "abess", beta_full, sel, mu_tr, mu_te)
## ---- (3) MCP/SCAD -------------------------------------------------------
for (pen in c("MCP", "SCAD")) {
t <- system.time(cv <- cv.ncvreg(X_tr, Y_tr, penalty=pen, family = ab_family))["elapsed"]
beta_full <- coef(cv); beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, paste0("ncvreg-", pen), beta_full, sel, mu_tr, mu_te)
}
## ---- (4) Lasso -------------------------------------------------------
t <- system.time(cvg <- cv.glmnet(X_tr, Y_tr, family= ab_family, alpha=1))["elapsed"]
beta_full <- as.vector(coef(cvg, s="lambda.min"))
beta_hat <- beta_full[-1]; intercept <- beta_full[1]
sel <- which(beta_hat != 0)
mu_tr <- family_mean(intercept + X_tr %*% beta_hat, fam, ntrial)
mu_te <- family_mean(intercept + X_te %*% beta_hat, fam, ntrial)
tbl <- add_row(tbl, t, "glmnet-Lasso", beta_full, sel, mu_tr, mu_te)
tbl
}
)
