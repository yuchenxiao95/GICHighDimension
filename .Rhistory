init_cols = init_cols,
'Calculate_BIC',
'Calculate_BIC_short',
Nsim = 5
)
result <- GICSelection(
X = X,
Y = Y,
init_cols,
'Calculate_BIC',
'Calculate_BIC_short',
Nsim = 5
)
# Extract final selection
final_selection <- result$selection_path[[length(result$selection_path)]]
final_selection
result
# Initialize Julia connection
JuliaCall::julia_setup()
JuliaCall::julia_library("Distributions")
# Set parameters
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Generate true columns
true_columns <- sort(sample(1:P, k, replace = FALSE))
# Create design matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Generate random matrix in Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta
true_beta <- rep(0, P)
true_beta[true_columns] <- 2
# Generate response
Y <- LP_to_Y(X, true_beta, family = "Normal")
# Run model selection
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols,
"Calculate_BIC",
"Calculate_BIC_short",
Nsim = 5L
)
# Tests for the result structure
expect_true(all(c("GIC_list", "GIC_coeff") %in% names(result)))
expect_type(result$GIC_list, "double")
expect_type(result$GIC_coeff, "double")
result
expect_true(all(c("GIC_list", "GIC_coeff") %in% names(result)))
expect_type(result$GIC_list, "double")
result$GIC_list
result$GIC_list)
result$GIC_list
result$GIC_coeff
setdiff
setdiff(result$GIC_list,   true_columns )
setdiff(result$GIC_coeff,   true_columns )
result$GIC_coeff[end]
result$GIC_coeff
result$GIC_coeff[-1]
result$GIC_coeff[[length(result$GIC_coeff)]]
setdiff(result$GIC_coeff[[length(result$GIC_coeff)]], true_columns)
true_columns
setdiff( true_columns, result$GIC_coeff[[length(result$GIC_coeff)]])
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
Y <- LP_to_Y(X, multi_beta, family = "MultivariateNormal")
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Create mean vector and covariance matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Assign to Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
true_signal_columns <- unique(unlist(multi_beta_true_columns))
# Create response covariance matrix (different from design matrix)
response_cov <- matrix(0.5, m, m)  # Example: 0.5 correlation between responses
diag(response_cov) <- 1.0          # Unit variance
# Generate response - NOW WITH COV_MATRIX SPECIFIED
Y <- LP_to_Y(
X = X,
true_beta = multi_beta,
family = "MultivariateNormal",
cov_matrix = response_cov  # This was missing!
)
N <- 1000L
P <- 500L
k <- 5L
rho <- 0.0
# Create mean vector and covariance matrix
mu <- rep(0, P)
cov_matrix <- matrix(rho, P, P)
diag(cov_matrix) <- 1.0
# Assign to Julia
JuliaCall::julia_assign("mu", mu)
JuliaCall::julia_assign("cov_matrix", cov_matrix)
JuliaCall::julia_assign("N", N)
X <- JuliaCall::julia_eval("rand(MvNormal(mu, cov_matrix), N)'")
# Create true beta coefficients
m <- 5L
multi_beta <- matrix(0, P, m)
multi_beta_true_columns <- vector("list", m)
for (i in 1:m) {
cols <- sort(sample(1:P, k, replace = FALSE))
multi_beta_true_columns[[i]] <- cols
multi_beta[cols, i] <- seq(10, 0.1, length.out = k)
}
true_signal_columns <- unique(unlist(multi_beta_true_columns))
# Create response covariance matrix (different from design matrix)
response_cov <- matrix(0.5, m, m)  # Example: 0.5 correlation between responses
diag(response_cov) <- 1.0          # Unit variance
# Generate response - NOW WITH COV_MATRIX SPECIFIED
Y <- LP_to_Y(
X = X,
true_beta = multi_beta,
family = "MultivariateNormal",
cov_matrix = response_cov  # This was missing!
)
init_cols <- 1:P
result <- GICSelection(
X = X,
Y = Y,
init_cols,
"Calculate_SIC",
"Calculate_SIC_short",
Nsim = 8L
)
setdiff(result$GIC_coeff[[length(result$GIC_coeff)]],   true_signal_columns )
setdiff(true_signal_columns , result$GIC_coeff[[length(result$GIC_coeff)]])
# First-time setup (installs Julia if missing)
GICModelSelection::setup_julia()
GICHighDimension::setup_julia()
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Document the changes
devtools::document()
devtools::load_all()
# Run tests
devtools::test()
# Run tests
devtools::test()
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Run tests
devtools::test()
# Call the R wrapper
result <- GICSelection(
X, Y, 1:p,
"Calculate_AIC",
"Calculate_AIC_short",
Nsim = 1
)
# Generate X
X <- mvrnorm(n = n, mu = rep(0, p), Sigma = cov_matrix)
# Step 1: Generate X from a multivariate normal distribution
n <- 100   # Reduced number of observations
p <- 10    # Reduced number of predictors
# Create a covariance matrix for the multivariate normal distribution
# Using an identity matrix for independent variables
cov_matrix <- diag(p)
# Generate X
X <- mvrnorm(n = n, mu = rep(0, p), Sigma = cov_matrix)
# Step 2: Generate 4 random indices and coefficients
num_indices <- 4  # Reduced number of non-zero coefficients
indices <- sample(1:p, num_indices, replace = FALSE)  # Random indices
coefficients <- numeric(p)  # Initialize coefficients
# Generate coefficients from the specified ranges
coefficients[indices] <- c(
runif(2, min = 5, max = 10),        # 2 from 5 to 10
runif(1, min = -10, max = -5),      # 1 from -10 to -5
runif(1, min = -1, max = 1)         # 1 from -1 to 1
)
# Step 3: Generate Y using the selected indices and coefficients
Y <- X %*% coefficients + rnorm(n)  # Add random noise
# Call the R wrapper
result <- GICSelection(
X, Y, 1:p,
"Calculate_AIC",
"Calculate_AIC_short",
Nsim = 1
)
1:p
GICSelection
result <- GICSelection(
X, Y, 1:p,
"Calculate_AIC",
"Calculate_AIC_short",
Nsim = 1
)
# Run tests
devtools::test()
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Run tests
devtools::test()
result <- GICSelection(
X, Y, 1:p,
"Calculate_AIC",
"Calculate_AIC_short",
Nsim = 1
)
Y
X %*% coefficients + rnorm(n)  #
X
coefficients
X %*% coefficients
Y = LP_to_Y(X, true_beta, family = "Normal", std = 1.0)
# Generate X
X <- mvrnorm(n = n, mu = rep(0, p), Sigma = cov_matrix)
# Step 2: Generate 4 random indices and coefficients
num_indices <- 4  # Reduced number of non-zero coefficients
indices <- sample(1:p, num_indices, replace = FALSE)  # Random indices
true_beta = numeric(p)  # Initialize coefficients
# Generate coefficients from the specified ranges
true_beta = [indices] <- c(
cov_matrix <- diag(p)
# Generate X
X <- mvrnorm(n = n, mu = rep(0, p), Sigma = cov_matrix)
# Step 2: Generate 4 random indices and coefficients
num_indices <- 4  # Reduced number of non-zero coefficients
indices <- sample(1:p, num_indices, replace = FALSE)  # Random indices
true_beta = numeric(p)  # Initialize coefficients
# Generate coefficients from the specified ranges
true_beta[indices] <- c(
runif(2, min = 5, max = 10),        # 2 from 5 to 10
runif(1, min = -10, max = -5),      # 1 from -10 to -5
runif(1, min = -1, max = 1)         # 1 from -1 to 1
)
# Step 3: Generate Y using the selected indices and coefficients
Y = LP_to_Y(X, true_beta, family = "Normal", std = 1.0)
# Call the R wrapper
result <- GICSelection(
X, Y, 1:p,
"Calculate_AIC",
"Calculate_AIC_short",
Nsim = 1
)
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
n <- 100  # number of observations
p <- 10   # number of predictors
k <- 3    # number of true signals
X <- matrix(rnorm(n * p), n, p)
X
true_beta <- c(rep(1.5, k), rep(0, p - k))
true_beta
Y = LP_to_Y(X, true_beta, family = "Normal", std = 1.0)
result <- GICSelection(
X = X,
Y = Y,
1:p,
"Calculate_SIC",
"Calculate_SIC_short",
Nsim = 3
)
result
print(result$selected_coeffs)
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Document the changes
devtools::document()
source("~/GICModelSelection/tests/testthat/tmp.R")
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document()
devtools::load_all()
devtools::document()
devtools::load_all()
devtools::document()
# Load all functions for testing
devtools::load_all()
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document()
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
devtools::test()
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::check_man()
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::check_man()
install.packages(c("covr", "knitr"))
install.packages(c("covr", "knitr"))
install.packages(c("covr", "knitr"))
devtools::document()
# Document the changes
devtools::document()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::document(); devtools::check_man()
devtools::check_rd()
getNamespaceExports("GICHighDimension")
devtools::document()
source("~/GICModelSelection/tests/testthat/tmp.R")
install.packages("rhub")
devtools::document()
devtools::check_man()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::release(check = TRUE)
usethis::use_cran_comments()
# Document the changes
devtools::document()
devtools::check_man()
devtools::load_all()
# Run tests
devtools::test()
# Export the functions on the namespace
roxygen2::roxygenise()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
devtools::release(check = TRUE)
devtools::document()
devtools::check_man()
devtools::load_all()
# Run tests
devtools::test()
roxygen2::roxygenise()
devtools::build_vignettes()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
source("~/GICModelSelection/tests/testthat/tmp.R")
devtools::document()
devtools::check_man()
# Load all functions for testing
devtools::load_all()
# Run tests
devtools::test()
# Export the functions on the namespace
roxygen2::roxygenise()
# Build vignettes
devtools::build_vignettes()
# Check package integrity
devtools::check()  # Fix any ERRORs/WARNINGs
# Build the package
devtools::build()
source("~/GICModelSelection/tests/testthat/tmp.R")
# Install the package locally from source
devtools::install(build_vignettes = FALSE, force = TRUE)
library(MASS)
library(GICHighDimension)
# Build the package
devtools::build()
source("~/GICModelSelection/tests/testthat/tmp.R")
